!!! Rutas y controladores !!!.- Symfony nos recomiendo usar las anotaciones cuando nosotros queremos generar rutas desde un controladore, por lo que nos ofrece un bundle para poder emplear dichas anotacinoes:
Instalacion:
    - composer require annotations
    Lo que hace esto instalar el bundle y ejecuta unas recetas las cuales nos configuran los archivos necesarios para su correcto uso de este paquete, automagicamente symfony lo coloca dentro las configuraciones.

Uso:
    - Podemos usarlo de la sig manera dentro de nuestros Controllers:
<?php

namespace App\Controller;

use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;

class LibraryController extends AbstractController
{
    private $logger;

    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    /**
     * @Route("/library/list", name="library_list")
     */
    public function list(Request $request)
    {
        $title = $request->get('title', 'Alegría');
        $this->logger->info('List action called');
        $response = new JsonResponse();
        $response->setData([
            'success' => true,
            'data' => [
                [
                    'id' => 1,
                    'title' => 'Hacia rutas salvajes'
                ],
                [
                    'id' => 2,
                    'title' => 'El nombre del viento'
                ],
                [
                    'id' => 2,
                    'title' => $title
                ]
            ]
        ]);
        return $response;
    }
}

Colocando una anotacion arriba de la clase donde queremos que sea una ruta, es recomendable darle un nombre a nuestra ruta para que sea mas facil acceder a ella mediante el nombre, También podemos ver un poco de Servicios que estamos inyectando directo en la funcion que sería el Request que lo que nos permite es tener toda la infoemacion de la request o peticion que hacemos en este ejem estamos pasanod por query un parametro llamado title donde capturamos en la ruta de nuestro navegador y el libre 3 tendra ese nombre el que le pasemos por query, tambien podemos darle un valor por defcto en el caso que no exita ese valor en la query pues tomará ese valor por defecto en nuestro ejm es fortunata, los controladores de symfony siempre pero siempre deben de retornar una respuesta para ello podemos usar el Objeto Response o JsonResponse como vemos en el ejm de arriba.
Los controladores pueden recibir los Servicios que son basicamente clases que hacen cosas y tpdo estos segicios estna dentro de una cosa que se llama containe, y asi podemos nosotros usar los servicios atraves de la inyeccion de dependencias. con este comando: bin/console debug:container nos dan una lista de los servicios que tenemos en nuestra app.

Como vemos en el ejm de arriba es una forma de inyectar los Servicios mediante su contructor, pero tambien gracias a una configuracion en el archivo config/services.yml podemos acceder a estos servicios s¿directo en la funcion misma donde lo vayamos a usar sin necesidad de utilizr el controlador ejm:

    services.yml => cabe recalcar en las versiones nuevas de symfony esto no viene configurado ya porque ya lo hace por defecto, pero en otras versiones en necesario colocar esto cro que de symfony 5.4 para abajo.

    ...resto of code
    App\Controller\:
        resource: '../src/Controller'
        tags: ['controller.service_arguments']

USO:
    <?php

namespace App\Controller;

use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;

class LibraryController extends AbstractController
{
    /**
     * @Route("/library/list", name="library_list")
     */
    public function list(Request $request, LoggerInterface $logger)
    {
        $title = $request->get('title', 'Alegría');
        $logger->info('List action called inside function');
        $response = new JsonResponse();
        $response->setData([
            'success' => true,
            'data' => [
                [
                    'id' => 1,
                    'title' => 'Hacia rutas salvajes'
                ],
                [
                    'id' => 2,
                    'title' => 'El nombre del viento'
                ],
                [
                    'id' => 2,
                    'title' => $title
                ]
            ]
        ]);
        return $response;
    }
}

Queda más limpio y no es necesario el uso del constructor si no como vemos podemos usar la intyecciion de dependencias directo en la funcion del controlador. Este funcionamiento es a nivel solo de controladores, si usamos en otro lado esto pues deberiamos de usar los constructores como vemos en el primer ejm, revisar documentacion para mas información, cambia segun las versiones de symfony este tipo de cosas.


!!! BASES DE DATOS !!!.- Symofny tiene un gestor de DB por execelencia vamos a llamarlo ORM llamado Doctrine, doctrine tiene como dis funciones :
    1) Nos abstrae la conexión con la BD, es decir, nos trae una capa que nos permite conectarnos a BD sin tenernos que nososotros picar la típicas conslutas de mySQL

    2)Funciona como un ORM lo cual nos permite mapear nuestras clases y objetos php con las tablas que tenmos en MySql y funciona correctamente.

Instalación:
    - composer require symfony/orm-pack
    Esto nos es mas que una receta de flex la cula le decimos que nos traiga todas la librerias, componentes y bundle para trabajar con doctrine, y ademas nos ejecuta una serie de scripts que nos va a configurar una serie de archivos el cual mos servira mucho para trabajar Dcotrine.

    Nos da en el archivo .env una linea de código muy importante que es lo que nos va a permitir conectarnos a la BD. La configuracion de db y cosas importantes como claves siempre las debemos generar dentro del .env.local siempre porque por defecto symfony esto no lo sube al repositorio

También tiene un bundle super práctico llamamdo make bundle el cual nos va a permitir por comandos ejecutar nuestras migraciones, nuestras entidades sin necesidad de hacer manualmente una creando getters y setters si no que automaticamente las crea el con el nombre de cada campo, es una dep de desarrollo:
Instalacion:
    - composer require --dev symfony/maker-bundle
    Entonces nosotros ya una vez teniendo la conexion a nuestra BD podemos lanzar el comando
    bin/console make:entity nameEntity esto nos creara las entidades nos pedira los campos que nosotros queremos colocar dentro de esta entidad y asi se crear automatocamente la entidad con los capos que le pasemos sus getters y setters.

    - Luego cuando estemos listos pues tenemos que crear las migraciones con el sig comando:
        php bin/console make:migration
        Esto creara un archivo dentro de la carpeta migrations donde tendrán las sentencias SQL para crear nuestra entidad y campos que le hayamos especificado.
    -Luego debemos de ejeuctar la migracion con bin/console doctrine:migration:migrate (bin/console d:m:m)

    como persistimos los datos, usando un Servicio de Doctrine llamado EntityManager, o cual nos va a permitir persistir entidades a BD lo debemos de usar como una inteccion de dependencias ejm:


    public function createBook(Request $request, EntityManagerInterface $em)
    {
        $book = new Book();
        $book->setTitle('Hacia rutas salvajes');
        $em->persist($book);
        $em->flush();
    }
}

Tenemos que hacer como vemos dos pasos el persist y el flush, con el persist le decimos, tengo una entidad de php en este caso la clase Book, gestionalo, le decimos que el objeto lo controle el, le decimos a Dcotrine quye tenemos un objeto de la clase libro, ya con el flush lo salvamos en el db.

!!! FOST REST BUNDLE !!!.- Es un bundle como Api PLatform que nos permite montar una api.
Instalación
    -composer require friendsofsymfony/rest-bundle.
    
    -Pero esto nos da un error porque necesita esto un serealizer, que lo que hace es como hiciumos a mano recuperar el librro y convertirlo a json pues este lo hace automaticamente por nosotros. asi que tenemos dos opciones uno de terceros y el propio que symfony saco llamado sereaizer lo vamos a instalar:
        - composer require symfony/serializer-pack
    Una vez instalado el serealizer debemos de agregar ls sig configuracion en el 
    config/packages/framework.yaml:
        ...code

        serializer:
            enabled: true
            mapping:
                paths: ['%Kernel.project_dir%/config/serializer']
    Con el mapping le decimos como queremos mapear las propiedades al formato que nosotros queremos, por ejm al id de un entidad le decimos que le queremos llamar casa por ejm etc. como esa carpeta serializer no existe pues la tenemos que crear dentro de config

    Dentro de esta carpeta creamos el archivo yaml de la entidad que estamos queriendo mapear ejm:
    config/serializer/Entity/Book.yaml

        App\Entity\Book:
    attributes:
        id: 
            groups: ['book']
        title:
            groups: ['book']
    Basicamente lo que hace los serializer es definir grupos de serealizacion de modo que en función de cual especiquemos podemos definir que propiedades del objeto aparecen o no.

Ahora temos que definir el Fost Rest Bundle:
    en el archivo routes.yaml agregamos lo sig:
        api:
            resource: ../../src/Controller/Api
            type: annotation
            prefix: /api
    Con esto estamos habilitando las rutas con el prefijo api.

Luego debemo de configurar el archivo fos_rest.yml (dentro esta la conf ya pegada).
Luego debemos de instalar un Validator pata que funione nuestro fostRest, el componente Validaotr nos permite validar entidades mas bien objetos en función de unas reglas que nosotros definamos. por ejm queremos hacer una llamada en post pues podemos validar los datos que estamos enviando:

Instalacion:
    - composer require symfony/validator twig doctrine/annotations
    El Validator depende de las annotations de doctrine por eso lo estamos instalado qui tambien y este doctrine depnde de Twig entonces por eso estamos instalando los 3.

Una vez tenemos todo esto podemos nosotros crear los controladores dentro de nuestra carpeta api que especificamos en la configuracion de la ruta oara qiue este tenga el prefijo /api a todas nuestras rutas ejm:

    <?php

namespace App\Controller\Api;

use App\Repository\BookRepository;
use FOS\RestBundle\Controller\AbstractFOSRestController;
use FOS\RestBundle\Controller\Annotations as Rest;
use Symfony\Component\HttpFoundation\Request;

class BooksController extends AbstractFOSRestController
{
    /**
     * @Rest\Get(path="/books")
     * @Rest\View(serializerGroups={"book"}, serializerEnableMaxDepthChecks=true)
     */
    public function getActions(Request $request, BookRepository $bookRepository)
    {
        return $bookRepository->findAll();
    }
}
 Las anotaciones deben ser de FostRestBundle

!!! FORMULARIOS !!!.- Para esto debemos de instalar el componente formulario de symfony:
    - composer require symfony/form
    Este nos permite declarar formularios y que procesaremos en nuestros controladores, dentro de src ccreamois un carpeta llamada Form y por convencion una carpeta llamada Type¿ y dentro creamos los files necesarios para esto de los Forms.
    src/Form/Type/BookFormType.php

    <?php

    namespace App\Form\Type;

    use App\Entity\Book;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class BookFormType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder->add('title', TextType::class);
        }

        public function configureOptions(OptionsResolver $resolver)
        {
            $resolver->setDefaults([
                'data_class' => Book::class
            ]);
        }
        
    }
Aqui lo que estamos haciendo en la primera funcione es inyectrar FormBuilderInterface $builder lo que nos da este servicio es una serie de metodo los cuales podemos nosotros usarlos en este caso estamos usando add que lo que hace es aladir un campo title y como segundo parametro recibe el tipo de campo en este caso TextType, luego en la 2da funcion  es inyectarnos el OptionsResolver, esto nos sirve para nosotros especidficarle a que entidad esta haciendo referencia.

Luego vamos a usarlo dentro de nuestro controller:


Aunque aveces falla esto por lo cual debemos de pasarle en el body un nombre porque symfony guarada los formularios que creamos con un nombre ejm:

Esto le pasamos en el body de la peticion:;
    "book_form":
        {
            "title": "El pozo de la ascención"
        }
Si queremos evitar esto, para no tener que estar colocnado cada rato el nombre del form, dentro de nuestro BookTypeForm en este caso vamos a añadir dos metodos ejm:

    ...rest of code
    //cuando trabajamos con Twig
    public function getBlockPrefix()
    {
        return '';
    }

    public function getName()
    {
        return '';
    }
De modo que asi ya no debemos especificar el nombre del form en la request.
Ahora vamos a colocar constrains a diff campos de nuestra app podemos usar yaml o annotations.

Con Annotations:
use Symfony\Component\Validator\Constraints as Assert;

    /**
     * @Assert\NotBlank
     */
    protected $firstName;

    Esto dentro del controller y arriba del campos que queremos que nos sea blanco o tenga alguna constraints:

Mediante yaml: tenemos que crear una carpeta dentro de config llamado validator y dentro un file que hacemos por convencion tenga el mismo nombre de la entidad que vamos a agregar este tipo de constraint

config/validator/Book.yaml

!!! DTO's y carga de imagenes !!!.- Cuando cargamos los imagenes debemos de siempre guradar dentro del campo solo el nombre del archivo nombre del fichero.
Podemos enviarlo de dos formas:
    1) Por formulario multipart donde la imagen aparece como un archivo adjunto.
    2) Enviar la imagen como si fuera un fichero en base 64 codificado. 
Para no crear campos automagicos como en este caso un campo base64Image que necesitamos para la imagen, no debemos de adaptar el DB a la Entidad si no la entidad al DB, por lo cual vamos a usar los
Data Transfer Objects (DTO's), lo cual representa los objetos que se envian a los formularios sin necesidad de tener que modificar nuestras entidades. Una convencion de symfony es crear una carpeta Model dentro de la carpeta Form que creamos para esto y dentro crear el archivo con lo sig:
    1) crear el archivo:
        src/Form/Model/BookDto.php
            <?php

            namespace App\Form\Model;

            class BookDto
            {
                public $title;
                public $base64Image;
            }

    2)En nuestrio BookFormType lo que debemos de hacer en la funcion configureOptions cambiarle el data_class => por el Dto que acabamos de crear.

    ...rest of code
        public function configureOptions(OptionsResolver $resolver)
        {
            $resolver->setDefaults([
                'data_class' => Book::class //antes
                'data_class' => BookDto::class //ahroa apunta al Dto.
            ]);
        }

    3) Cmbiar tambien la validacion que haciamos antes que apunte tambien a este Dto
        //antes
        App\Entity\Book:
        properties:
        
        //Ahora apunta al Dto. como convencio podemos cambiar el nombre del archivo yaml por BookDto.yaml
        App\Form\Model\BookDto:
        properties:

   4) Pero los dto que estamos creando no son servicios por lo cual debemos de configurar el archivo services.yaml para estos no lo tomen como servicios, porque no solo son objetos que vamos a usar para tranajar con los formularios.
    config/services.yaml
        .. rest of code
        - '../src/Form/Model'
            añadimos esto pata que no lo tome como servicio dentro de exclude
            App\:
                resource: '../src/'
                exclude:

    5) Debemos de cambiar el controller, lo que queremos hacer aqui es, que todo lo que se mande por el Dto instanciandolo le tenemos que colocar al la entidad Book en este caso, es decir el dto recibe el title y la imagen entonces como estamos apuntando todo al Dto, lo que tenga el Dto le cargamos a la entidad libro xejm:
        /**
         * @Rest\Post(path="/books")
         * @Rest\View(serializerGroups={"book"}, serializerEnableMaxDepthChecks=true)
        */
        public function postActions(Request $request, EntityManagerInterface $em)
        {
            $bookDto = new BookDto();
            $form = $this->createForm(BookFormType::class, $bookDto);
            $form->handleRequest($request);
            if ($form->isSubmitted() && $form->isValid()) {
                $book = new Book();
                $book->setTitle($bookDto->title);
                $em->persist($book);
                $em->flush();
                return $book;
            }
            return $form;
        }
    }

  CARGA DE IMAGENES.- Lo vamos ha hacer con el bundle flysystem-bundle, nos permite subir qechivos a nivel local o cdn como s3:
  Instalacion:
    - composer require league/flysystem-bundle
    Esto nos configurara un archivo dentro de la carpeta packages un archivo llamado flysystem.yaml debemos de configurar de la siguiente manera:
        flysystem:
            storages:
                default.storage:
                    adapter: 'local'
                    # adapter: 's3'
                    options:
                        directory: '%kernel.project_dir%/public/storage/default'
        Lo único que cambiamos aqui en el directory colocamos public en ves de var para que se puedan servir desde ek public que es donde se muestran las imagenes.

    Luego debemos de hacer la inyeccion de dependencias en donde vayamos a usar el servicio que seria en el BooksController ejm:
        
        Es importante que la variable $defaultStorage tenga el mismo nombre se llame igual en donde se creao el archivo flysystem.yaml

        flysystem:
            storages:
            default.storage: => se tiene que llamar igual a esta variable
                adapter: 'local'
                # adapter: 's3'
                options:
                    directory: '%kernel.project_dir%/public/storage/default'

    Luego en nuestro controlador debemos de hacer 4 tranformaciones para poder cargar el archivo el nombre mejor dicho x ejm:

    /**
     * @Rest\Post(path="/books")
     * @Rest\View(serializerGroups={"book"}, serializerEnableMaxDepthChecks=true)
     */
    public function postActions(
        Request $request,
        EntityManagerInterface $em,
        FilesystemOperator $defaultStorage
    ) {
        $bookDto = new BookDto();
        $form = $this->createForm(BookFormType::class, $bookDto);
        $form->handleRequest($request);
        if ($form->isSubmitted() && $form->isValid()) {
            //tranformaciones
            $extension = explode('/', mime_content_type($bookDto->base64Image))[1]; => con esto estamos sacando la extension, del bookDto cogemos el campo base64Image en este caso o el campo donde estemos yendo a alamacenar el nombre de la imagen.

            $data = explode(',', $bookDto->base64Image); => aqui estamos dividiendo el contenido del campo base64Image en dos partes porque las url de bas64 tiene una separacion por coma, siendo la primera parte la informacion del fichero y la segunda parte la imagen codificada en bse64 tal cual.

            $fileName = sprintf('%s.%s', uniqid('book_', true), $extension); => Aqui estamos generando un nombre de fichero, mediante la funcion uniqid de php metiendo un prefijo book_, con el true le estamos obligando que tenga 23 caracteres para que no nos colicionen los nombres de los fichero como segundo parametro le pasamos la $extension, osea la extension que hayamos calculado de la imagen a subir

            $defaultStorage->write($fileName, base64_decode($data[1])); => Todo esto porque el $defautStorage en su funcion write recibe dos argumentos, el primero el path en el que queremos escribir y como segundo parametro los contenidos, osea, la imagen decodificada, es decir el segundo pedazo de la imagen explotada por coma(,), como dijimos en data estamos diviendo la primera parte la info del file y la segunda la imagen decodificada.

            //Persistencia
            $book = new Book();
            $book->setTitle($bookDto->title);
            $book->setImage($fileName);
            $em->persist($book);
            $em->flush();
            return $book;
        }
        return $form;
    }

Pero vemos que tenemos un problema, el cúal nosotros estamos devolviendo el nombre de la imagen solo, lo que tendríamos que hacer es cuando hacemos la peticion de nuestra api, debemos de devolver el valor de la imagen pero la url completa a ese servicio par poder acceder desde fuera x ejm devolvemos name_image.jpeg y queremos que devuelva esto => http://nube.com/name_image.jpeg.
Podemos lograrlo con el componente Serializer de symfony, el cúal nos permite engancharnos al proceso de serialización para realizr las modificaciones que necesitemos paso:
    1) Creamos una carpeta llamada Serializer en nuestra src y dentro un archivo llamado BookNormalizer.php, un BookNormalizer se ennarga de hacer la basicamente de hacer la transformacion de Entidad a json ejm:
    src/Serializer/BookSerializer.php

    <?php

        namespace App\Serializer;

        use App\Entity\Book;
        use Symfony\Component\HttpFoundation\UrlHelper;
        use Symfony\Component\Serializer\Normalizer\ContextAwareNormalizerInterface;
        use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;

        class BookNormalizer implements ContextAwareNormalizerInterface
        {
            private $normalizer;
            private $urlHelper;

            public function __construct(
                ObjectNormalizer $normalizer,
                UrlHelper $urlHelper
            ) {
                $this->normalizer = $normalizer;
                $this->urlHelper = $urlHelper;
            }

            public function normalize($book, string $format = null, array $context = [])
            {
                $data = $this->normalizer->normalize($book, $format, $context);

                if(!empty($book->getImage())) {
                    $data['image'] = $this->urlHelper->getAbsoluteUrl('/storage/default/' . $book->getImage());
                }

                return $data;
            }

            public function supportsNormalization($data, string $format = null, array $context = [])
            {
                return $data instanceof Book;
            }
        }
    Este normalizador nos pide que implementoemos dos funciones, la normalize que es donde nosotros tenemos y podemos modificar los que queremos como en este caso estamos pasando un complemento donde a la imagen le añadimos un path absoluto para poder acceder a la imagen.
    Y la segundo funcion supportsNormalization que lo que tenemos que hacer y lo mas importabnte es pasarle en el retunr el nombre de la entidad que va a soportar esto en este caso Book
    return $data instanceof Book; asi symfony sabra a que entidad hace referencia y los datos que tiene que cambiar.

!!! PHPUnit !!!.- Es una herramineta para poder realixzar test, lo que nos ayuda basicamdnte es ha comprobar que nuestros servicios apesar que por el camino lo vayamos modificando pues este nos devuelva siempre lo mismo que hemos implementado. Nos permite declara test unitarios y test funcionales, nos permite ejecutar por linea de comandos.
Instalación:
    - composer require --dev symfony/phpunit-bridge
    Una vez instalado esto nos pedira que lancemos el sig comando tambien para que nos traiga la libreria phpunit en sí. php bin/phpunit

Para hacer test de Web como el sig ejem debemos de instalar tambien otro paquete por que si no nos da un error ejm:
    composer require --dev symfony/browser-kit symfony/css-selector
    tests/Controller/Api
    <?php

    namespace App\Tests\Controller;

    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

    class BookControllerTest extends WebTestCase
    {
        public function testCreateBook()
        {
            $client = static::createClient();

            $client->request('GET', '/api/books');

            $this->assertEquals(400, $client->getResponse()->getStatusCode());
        }
    }

Para nosotro poder hacer test de enpoints, lo recomendable y necesesario para que nos nos falle los test es creasr un db de prueba, symfony nos permite en el package dentro de config generr diff tipos de configuraciones dependiendo el entorno en el que estemos por ejm, aqui estamos creando nosotros un db sqlite donde le estamos pasando los datos que tenemos en nuestro db y para las pruebas de test x ejm:
    - config/packages/test/doctrine.yaml
    doctrine:
    dbal:
        driver: pdo_sqlite
        path: "%kernel.cache_dir%/test.db"
        url: null

    - Luego debemos de lanzar el sig comando:
        bin/console doctrine:database:create --env=test

    - Luego lanzar las migraciones contra esta db de prueba :
        bin/console doctrine:schema:update --env=test --force
