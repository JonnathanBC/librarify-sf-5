!!! Rutas y controladores !!!.- Symfony nos recomiendo usar las anotaciones cuando nosotros queremos generar rutas desde un controladore, por lo que nos ofrece un bundle para poder emplear dichas anotacinoes:
Instalacion:
    - composer require annotations
    Lo que hace esto instalar el bundle y ejecuta unas recetas las cuales nos configuran los archivos necesarios para su correcto uso de este paquete, automagicamente symfony lo coloca dentro las configuraciones.

Uso:
    - Podemos usarlo de la sig manera dentro de nuestros Controllers:
<?php

namespace App\Controller;

use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;

class LibraryController extends AbstractController
{
    private $logger;

    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    /**
     * @Route("/library/list", name="library_list")
     */
    public function list(Request $request)
    {
        $title = $request->get('title', 'Alegría');
        $this->logger->info('List action called');
        $response = new JsonResponse();
        $response->setData([
            'success' => true,
            'data' => [
                [
                    'id' => 1,
                    'title' => 'Hacia rutas salvajes'
                ],
                [
                    'id' => 2,
                    'title' => 'El nombre del viento'
                ],
                [
                    'id' => 2,
                    'title' => $title
                ]
            ]
        ]);
        return $response;
    }
}

Colocando una anotacion arriba de la clase donde queremos que sea una ruta, es recomendable darle un nombre a nuestra ruta para que sea mas facil acceder a ella mediante el nombre, También podemos ver un poco de Servicios que estamos inyectando directo en la funcion que sería el Request que lo que nos permite es tener toda la infoemacion de la request o peticion que hacemos en este ejem estamos pasanod por query un parametro llamado title donde capturamos en la ruta de nuestro navegador y el libre 3 tendra ese nombre el que le pasemos por query, tambien podemos darle un valor por defcto en el caso que no exita ese valor en la query pues tomará ese valor por defecto en nuestro ejm es fortunata, los controladores de symfony siempre pero siempre deben de retornar una respuesta para ello podemos usar el Objeto Response o JsonResponse como vemos en el ejm de arriba.
Los controladores pueden recibir los Servicios que son basicamente clases que hacen cosas y tpdo estos segicios estna dentro de una cosa que se llama containe, y asi podemos nosotros usar los servicios atraves de la inyeccion de dependencias. con este comando: bin/console debug:container nos dan una lista de los servicios que tenemos en nuestra app.

Como vemos en el ejm de arriba es una forma de inyectar los Servicios mediante su contructor, pero tambien gracias a una configuracion en el archivo config/services.yml podemos acceder a estos servicios s¿directo en la funcion misma donde lo vayamos a usar sin necesidad de utilizr el controlador ejm:

    services.yml => cabe recalcar en las versiones nuevas de symfony esto no viene configurado ya porque ya lo hace por defecto, pero en otras versiones en necesario colocar esto cro que de symfony 5.4 para abajo.

    ...resto of code
    App\Controller\:
        resource: '../src/Controller'
        tags: ['controller.service_arguments']

USO:
    <?php

namespace App\Controller;

use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;

class LibraryController extends AbstractController
{
    /**
     * @Route("/library/list", name="library_list")
     */
    public function list(Request $request, LoggerInterface $logger)
    {
        $title = $request->get('title', 'Alegría');
        $logger->info('List action called inside function');
        $response = new JsonResponse();
        $response->setData([
            'success' => true,
            'data' => [
                [
                    'id' => 1,
                    'title' => 'Hacia rutas salvajes'
                ],
                [
                    'id' => 2,
                    'title' => 'El nombre del viento'
                ],
                [
                    'id' => 2,
                    'title' => $title
                ]
            ]
        ]);
        return $response;
    }
}

Queda más limpio y no es necesario el uso del constructor si no como vemos podemos usar la intyecciion de dependencias directo en la funcion del controlador. Este funcionamiento es a nivel solo de controladores, si usamos en otro lado esto pues deberiamos de usar los constructores como vemos en el primer ejm, revisar documentacion para mas información, cambia segun las versiones de symfony este tipo de cosas.


!!! BASES DE DATOS !!!.- Symofny tiene un gestor de DB por execelencia vamos a llamarlo ORM llamado Doctrine, doctrine tiene como dis funciones :
    1) Nos abstrae la conexión con la BD, es decir, nos trae una capa que nos permite conectarnos a BD sin tenernos que nososotros picar la típicas conslutas de mySQL

    2)Funciona como un ORM lo cual nos permite mapear nuestras clases y objetos php con las tablas que tenmos en MySql y funciona correctamente.

Instalación:
    - composer require symfony/orm-pack
    Esto nos es mas que una receta de flex la cula le decimos que nos traiga todas la librerias, componentes y bundle para trabajar con doctrine, y ademas nos ejecuta una serie de scripts que nos va a configurar una serie de archivos el cual mos servira mucho para trabajar Dcotrine.

    Nos da en el archivo .env una linea de código muy importante que es lo que nos va a permitir conectarnos a la BD. La configuracion de db y cosas importantes como claves siempre las debemos generar dentro del .env.local siempre porque por defecto symfony esto no lo sube al repositorio

También tiene un bundle super práctico llamamdo make bundle el cual nos va a permitir por comandos ejecutar nuestras migraciones, nuestras entidades sin necesidad de hacer manualmente una creando getters y setters si no que automaticamente las crea el con el nombre de cada campo, es una dep de desarrollo:
Instalacion:
    - composer require --dev symfony/maker-bundle
    Entonces nosotros ya una vez teniendo la conexion a nuestra BD podemos lanzar el comando
    bin/console make:entity nameEntity esto nos creara las entidades nos pedira los campos que nosotros queremos colocar dentro de esta entidad y asi se crear automatocamente la entidad con los capos que le pasemos sus getters y setters.

    - Luego cuando estemos listos pues tenemos que crear las migraciones con el sig comando:
        php bin/console make:migration
        Esto creara un archivo dentro de la carpeta migrations donde tendrán las sentencias SQL para crear nuestra entidad y campos que le hayamos especificado.
    -Luego debemos de ejeuctar la migracion con bin/console doctrine:migration:migrate (bin/console d:m:m)

    como persistimos los datos, usando un Servicio de Doctrine llamado EntityManager, o cual nos va a permitir persistir entidades a BD lo debemos de usar como una inteccion de dependencias ejm:


    public function createBook(Request $request, EntityManagerInterface $em)
    {
        $book = new Book();
        $book->setTitle('Hacia rutas salvajes');

        $em->persist($book);
        $em->flush();
    }
}

Tenemos que hacer como vemos dos pasos el persist y el flush, con el persist le decimos, tengo una entidad de php en este caso la clase Book, gestionalo, le decimos que el objeto lo controle el, le decimos a Dcotrine quye tenemos un objeto de la clase libro, ya con el flush lo salvamos en el db