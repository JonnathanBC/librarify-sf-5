!!! Rutas y controladores !!!.- Symfony nos recomiendo usar las anotaciones cuando nosotros queremos generar rutas desde un controladore, por lo que nos ofrece un bundle para poder emplear dichas anotacinoes:
Para bajar la establidad a composer:
    - composer config minimum-stability dev
Instalacion:
    - composer require annotations
    Lo que hace esto instalar el bundle y ejecuta unas recetas las cuales nos configuran los archivos necesarios para su correcto uso de este paquete, automagicamente symfony lo coloca dentro las configuraciones.

Uso:
    - Podemos usarlo de la sig manera dentro de nuestros Controllers:
<?php

namespace App\Controller;

use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;

class LibraryController extends AbstractController
{
    private $logger;

    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    /**
     * @Route("/library/list", name="library_list")
     */
    public function list(Request $request)
    {
        $title = $request->get('title', 'Alegría');
        $this->logger->info('List action called');
        $response = new JsonResponse();
        $response->setData([
            'success' => true,
            'data' => [
                [
                    'id' => 1,
                    'title' => 'Hacia rutas salvajes'
                ],
                [
                    'id' => 2,
                    'title' => 'El nombre del viento'
                ],
                [
                    'id' => 2,
                    'title' => $title
                ]
            ]
        ]);
        return $response;
    }
}

Colocando una anotacion arriba de la clase donde queremos que sea una ruta, es recomendable darle un nombre a nuestra ruta para que sea mas facil acceder a ella mediante el nombre, También podemos ver un poco de Servicios que estamos inyectando directo en la funcion que sería el Request que lo que nos permite es tener toda la infoemacion de la request o peticion que hacemos en este ejem estamos pasanod por query un parametro llamado title donde capturamos en la ruta de nuestro navegador y el libre 3 tendra ese nombre el que le pasemos por query, tambien podemos darle un valor por defcto en el caso que no exita ese valor en la query pues tomará ese valor por defecto en nuestro ejm es fortunata, los controladores de symfony siempre pero siempre deben de retornar una respuesta para ello podemos usar el Objeto Response o JsonResponse como vemos en el ejm de arriba.
Los controladores pueden recibir los Servicios que son basicamente clases que hacen cosas y tpdo estos segicios estna dentro de una cosa que se llama containe, y asi podemos nosotros usar los servicios atraves de la inyeccion de dependencias. con este comando: bin/console debug:container nos dan una lista de los servicios que tenemos en nuestra app.

Como vemos en el ejm de arriba es una forma de inyectar los Servicios mediante su contructor, pero tambien gracias a una configuracion en el archivo config/services.yml podemos acceder a estos servicios s¿directo en la funcion misma donde lo vayamos a usar sin necesidad de utilizr el controlador ejm:

    services.yml => cabe recalcar en las versiones nuevas de symfony esto no viene configurado ya porque ya lo hace por defecto, pero en otras versiones en necesario colocar esto cro que de symfony 5.4 para abajo.

    ...resto of code
    App\Controller\:
        resource: '../src/Controller'
        tags: ['controller.service_arguments']

USO:
    <?php

namespace App\Controller;

use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;

class LibraryController extends AbstractController
{
    /**
     * @Route("/library/list", name="library_list")
     */
    public function list(Request $request, LoggerInterface $logger)
    {
        $title = $request->get('title', 'Alegría');
        $logger->info('List action called inside function');
        $response = new JsonResponse();
        $response->setData([
            'success' => true,
            'data' => [
                [
                    'id' => 1,
                    'title' => 'Hacia rutas salvajes'
                ],
                [
                    'id' => 2,
                    'title' => 'El nombre del viento'
                ],
                [
                    'id' => 2,
                    'title' => $title
                ]
            ]
        ]);
        return $response;
    }
}

Queda más limpio y no es necesario el uso del constructor si no como vemos podemos usar la intyecciion de dependencias directo en la funcion del controlador. Este funcionamiento es a nivel solo de controladores, si usamos en otro lado esto pues deberiamos de usar los constructores como vemos en el primer ejm, revisar documentacion para mas información, cambia segun las versiones de symfony este tipo de cosas.


!!! BASES DE DATOS !!!.- Symofny tiene un gestor de DB por execelencia vamos a llamarlo ORM llamado Doctrine, doctrine tiene como dis funciones :
    1) Nos abstrae la conexión con la BD, es decir, nos trae una capa que nos permite conectarnos a BD sin tenernos que nososotros picar la típicas conslutas de mySQL

    2)Funciona como un ORM lo cual nos permite mapear nuestras clases y objetos php con las tablas que tenmos en MySql y funciona correctamente.

Instalación:
    - composer require symfony/orm-pack
    Esto nos es mas que una receta de flex la cula le decimos que nos traiga todas la librerias, componentes y bundle para trabajar con doctrine, y ademas nos ejecuta una serie de scripts que nos va a configurar una serie de archivos el cual mos servira mucho para trabajar Dcotrine.

    Nos da en el archivo .env una linea de código muy importante que es lo que nos va a permitir conectarnos a la BD. La configuracion de db y cosas importantes como claves siempre las debemos generar dentro del .env.local siempre porque por defecto symfony esto no lo sube al repositorio

También tiene un bundle super práctico llamamdo make bundle el cual nos va a permitir por comandos ejecutar nuestras migraciones, nuestras entidades sin necesidad de hacer manualmente una creando getters y setters si no que automaticamente las crea el con el nombre de cada campo, es una dep de desarrollo:
Instalacion:
    - composer require --dev symfony/maker-bundle
    Entonces nosotros ya una vez teniendo la conexion a nuestra BD podemos lanzar el comando
    bin/console make:entity nameEntity esto nos creara las entidades nos pedira los campos que nosotros queremos colocar dentro de esta entidad y asi se crear automatocamente la entidad con los capos que le pasemos sus getters y setters.

    - Luego cuando estemos listos pues tenemos que crear las migraciones con el sig comando:
        php bin/console make:migration
        Esto creara un archivo dentro de la carpeta migrations donde tendrán las sentencias SQL para crear nuestra entidad y campos que le hayamos especificado.
    -Luego debemos de ejeuctar la migracion con bin/console doctrine:migration:migrate (bin/console d:m:m)

    como persistimos los datos, usando un Servicio de Doctrine llamado EntityManager, o cual nos va a permitir persistir entidades a BD lo debemos de usar como una inteccion de dependencias ejm:


    public function createBook(Request $request, EntityManagerInterface $em)
    {
        $book = new Book();
        $book->setTitle('Hacia rutas salvajes');
        $em->persist($book);
        $em->flush();
    }
}

Tenemos que hacer como vemos dos pasos el persist y el flush, con el persist le decimos, tengo una entidad de php en este caso la clase Book, gestionalo, le decimos que el objeto lo controle el, le decimos a Dcotrine quye tenemos un objeto de la clase libro, ya con el flush lo salvamos en el db.

!!! FOST REST BUNDLE !!!.- Es un bundle como Api PLatform que nos permite montar una api.
Instalación
    -composer require friendsofsymfony/rest-bundle.
    
    -Pero esto nos da un error porque necesita esto un serealizer, que lo que hace es como hiciumos a mano recuperar el librro y convertirlo a json pues este lo hace automaticamente por nosotros. asi que tenemos dos opciones uno de terceros y el propio que symfony saco llamado sereaizer lo vamos a instalar:
        - composer require symfony/serializer-pack
    Una vez instalado el serealizer debemos de agregar ls sig configuracion en el 
    config/packages/framework.yaml:
        ...code

        serializer:
            enabled: true
            mapping:
                paths: ['%Kernel.project_dir%/config/serializer']
    Con el mapping le decimos como queremos mapear las propiedades al formato que nosotros queremos, por ejm al id de un entidad le decimos que le queremos llamar casa por ejm etc. como esa carpeta serializer no existe pues la tenemos que crear dentro de config

    Dentro de esta carpeta creamos el archivo yaml de la entidad que estamos queriendo mapear ejm:
    config/serializer/Entity/Book.yaml

        App\Entity\Book:
    attributes:
        id: 
            groups: ['book']
        title:
            groups: ['book']
    Basicamente lo que hace los serializer es definir grupos de serealizacion de modo que en función de cual especiquemos podemos definir que propiedades del objeto aparecen o no.

Ahora temos que definir el Fost Rest Bundle:
    en el archivo routes.yaml agregamos lo sig:
        api:
            resource: ../../src/Controller/Api
            type: annotation
            prefix: /api
    Con esto estamos habilitando las rutas con el prefijo api.

Luego debemo de configurar el archivo fos_rest.yml (dentro esta la conf ya pegada).
Luego debemos de instalar un Validator pata que funione nuestro fostRest, el componente Validaotr nos permite validar entidades mas bien objetos en función de unas reglas que nosotros definamos. por ejm queremos hacer una llamada en post pues podemos validar los datos que estamos enviando:

Instalacion:
    - composer require symfony/validator twig doctrine/annotations
    El Validator depende de las annotations de doctrine por eso lo estamos instalado qui tambien y este doctrine depnde de Twig entonces por eso estamos instalando los 3.

Una vez tenemos todo esto podemos nosotros crear los controladores dentro de nuestra carpeta api que especificamos en la configuracion de la ruta oara qiue este tenga el prefijo /api a todas nuestras rutas ejm:

    <?php

namespace App\Controller\Api;

use App\Repository\BookRepository;
use FOS\RestBundle\Controller\AbstractFOSRestController;
use FOS\RestBundle\Controller\Annotations as Rest;
use Symfony\Component\HttpFoundation\Request;

class BooksController extends AbstractFOSRestController
{
    /**
     * @Rest\Get(path="/books")
     * @Rest\View(serializerGroups={"book"}, serializerEnableMaxDepthChecks=true)
     */
    public function getActions(Request $request, BookRepository $bookRepository)
    {
        return $bookRepository->findAll();
    }
}
 Las anotaciones deben ser de FostRestBundle

!!! FORMULARIOS !!!.- Para esto debemos de instalar el componente formulario de symfony:
    - composer require symfony/form
    Este nos permite declarar formularios y que procesaremos en nuestros controladores, dentro de src ccreamois un carpeta llamada Form y por convencion una carpeta llamada Type¿ y dentro creamos los files necesarios para esto de los Forms.
    src/Form/Type/BookFormType.php

    <?php

    namespace App\Form\Type;

    use App\Entity\Book;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class BookFormType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder->add('title', TextType::class);
        }

        public function configureOptions(OptionsResolver $resolver)
        {
            $resolver->setDefaults([
                'data_class' => Book::class
            ]);
        }
        
    }
Aqui lo que estamos haciendo en la primera funcione es inyectrar FormBuilderInterface $builder lo que nos da este servicio es una serie de metodo los cuales podemos nosotros usarlos en este caso estamos usando add que lo que hace es aladir un campo title y como segundo parametro recibe el tipo de campo en este caso TextType, luego en la 2da funcion  es inyectarnos el OptionsResolver, esto nos sirve para nosotros especidficarle a que entidad esta haciendo referencia.

Luego vamos a usarlo dentro de nuestro controller:


Aunque aveces falla esto por lo cual debemos de pasarle en el body un nombre porque symfony guarada los formularios que creamos con un nombre ejm:

Esto le pasamos en el body de la peticion:;
    "book_form":
        {
            "title": "El pozo de la ascención"
        }
Si queremos evitar esto, para no tener que estar colocnado cada rato el nombre del form, dentro de nuestro BookTypeForm en este caso vamos a añadir dos metodos ejm:

    ...rest of code
    //cuando trabajamos con Twig
    public function getBlockPrefix()
    {
        return '';
    }

    public function getName()
    {
        return '';
    }
De modo que asi ya no debemos especificar el nombre del form en la request.
Ahora vamos a colocar constrains a diff campos de nuestra app podemos usar yaml o annotations.

Con Annotations:
use Symfony\Component\Validator\Constraints as Assert;

    /**
     * @Assert\NotBlank
     */
    protected $firstName;

    Esto dentro del controller y arriba del campos que queremos que nos sea blanco o tenga alguna constraints:

Mediante yaml: tenemos que crear una carpeta dentro de config llamado validator y dentro un file que hacemos por convencion tenga el mismo nombre de la entidad que vamos a agregar este tipo de constraint

config/validator/Book.yaml

!!! DTO's y carga de imagenes !!!.- Cuando cargamos los imagenes debemos de siempre guradar dentro del campo solo el nombre del archivo nombre del fichero.
Podemos enviarlo de dos formas:
    1) Por formulario multipart donde la imagen aparece como un archivo adjunto.
    2) Enviar la imagen como si fuera un fichero en base 64 codificado. 
Para no crear campos automagicos como en este caso un campo base64Image que necesitamos para la imagen, no debemos de adaptar el DB a la Entidad si no la entidad al DB, por lo cual vamos a usar los
Data Transfer Objects (DTO's), lo cual representa los objetos que se envian a los formularios sin necesidad de tener que modificar nuestras entidades. Una convencion de symfony es crear una carpeta Model dentro de la carpeta Form que creamos para esto y dentro crear el archivo con lo sig:
    1) crear el archivo:
        src/Form/Model/BookDto.php
            <?php

            namespace App\Form\Model;

            class BookDto
            {
                public $title;
                public $base64Image;
            }

    2)En nuestrio BookFormType lo que debemos de hacer en la funcion configureOptions cambiarle el data_class => por el Dto que acabamos de crear.

    ...rest of code
        public function configureOptions(OptionsResolver $resolver)
        {
            $resolver->setDefaults([
                'data_class' => Book::class //antes
                'data_class' => BookDto::class //ahroa apunta al Dto.
            ]);
        }

    3) Cmbiar tambien la validacion que haciamos antes que apunte tambien a este Dto
        //antes
        App\Entity\Book:
        properties:
        
        //Ahora apunta al Dto. como convencio podemos cambiar el nombre del archivo yaml por BookDto.yaml
        App\Form\Model\BookDto:
        properties:

   4) Pero los dto que estamos creando no son servicios por lo cual debemos de configurar el archivo services.yaml para estos no lo tomen como servicios, porque no solo son objetos que vamos a usar para tranajar con los formularios.
    config/services.yaml
        .. rest of code
        - '../src/Form/Model'
            añadimos esto pata que no lo tome como servicio dentro de exclude
            App\:
                resource: '../src/'
                exclude:

    5) Debemos de cambiar el controller, lo que queremos hacer aqui es, que todo lo que se mande por el Dto instanciandolo le tenemos que colocar al la entidad Book en este caso, es decir el dto recibe el title y la imagen entonces como estamos apuntando todo al Dto, lo que tenga el Dto le cargamos a la entidad libro xejm:
        /**
         * @Rest\Post(path="/books")
         * @Rest\View(serializerGroups={"book"}, serializerEnableMaxDepthChecks=true)
        */
        public function postActions(Request $request, EntityManagerInterface $em)
        {
            $bookDto = new BookDto();
            $form = $this->createForm(BookFormType::class, $bookDto);
            $form->handleRequest($request);
            if ($form->isSubmitted() && $form->isValid()) {
                $book = new Book();
                $book->setTitle($bookDto->title);
                $em->persist($book);
                $em->flush();
                return $book;
            }
            return $form;
        }
    }

  CARGA DE IMAGENES.- Lo vamos ha hacer con el bundle flysystem-bundle, nos permite subir qechivos a nivel local o cdn como s3:
  Instalacion:
    - composer require league/flysystem-bundle
    Esto nos configurara un archivo dentro de la carpeta packages un archivo llamado flysystem.yaml debemos de configurar de la siguiente manera:
        flysystem:
            storages:
                default.storage:
                    adapter: 'local'
                    # adapter: 's3'
                    options:
                        directory: '%kernel.project_dir%/public/storage/default'
        Lo único que cambiamos aqui en el directory colocamos public en ves de var para que se puedan servir desde ek public que es donde se muestran las imagenes.

    Luego debemos de hacer la inyeccion de dependencias en donde vayamos a usar el servicio que seria en el BooksController ejm:
        
        Es importante que la variable $defaultStorage tenga el mismo nombre se llame igual en donde se creao el archivo flysystem.yaml

        flysystem:
            storages:
            default.storage: => se tiene que llamar igual a esta variable
                adapter: 'local'
                # adapter: 's3'
                options:
                    directory: '%kernel.project_dir%/public/storage/default'

    Luego en nuestro controlador debemos de hacer 4 tranformaciones para poder cargar el archivo el nombre mejor dicho x ejm:

    /**
     * @Rest\Post(path="/books")
     * @Rest\View(serializerGroups={"book"}, serializerEnableMaxDepthChecks=true)
     */
    public function postActions(
        Request $request,
        EntityManagerInterface $em,
        FilesystemOperator $defaultStorage
    ) {
        $bookDto = new BookDto();
        $form = $this->createForm(BookFormType::class, $bookDto);
        $form->handleRequest($request);
        if ($form->isSubmitted() && $form->isValid()) {
            //tranformaciones
            $extension = explode('/', mime_content_type($bookDto->base64Image))[1]; => con esto estamos sacando la extension, del bookDto cogemos el campo base64Image en este caso o el campo donde estemos yendo a alamacenar el nombre de la imagen.

            $data = explode(',', $bookDto->base64Image); => aqui estamos dividiendo el contenido del campo base64Image en dos partes porque las url de bas64 tiene una separacion por coma, siendo la primera parte la informacion del fichero y la segunda parte la imagen codificada en bse64 tal cual.

            $fileName = sprintf('%s.%s', uniqid('book_', true), $extension); => Aqui estamos generando un nombre de fichero, mediante la funcion uniqid de php metiendo un prefijo book_, con el true le estamos obligando que tenga 23 caracteres para que no nos colicionen los nombres de los fichero como segundo parametro le pasamos la $extension, osea la extension que hayamos calculado de la imagen a subir

            $defaultStorage->write($fileName, base64_decode($data[1])); => Todo esto porque el $defautStorage en su funcion write recibe dos argumentos, el primero el path en el que queremos escribir y como segundo parametro los contenidos, osea, la imagen decodificada, es decir el segundo pedazo de la imagen explotada por coma(,), como dijimos en data estamos diviendo la primera parte la info del file y la segunda la imagen decodificada.

            //Persistencia
            $book = new Book();
            $book->setTitle($bookDto->title);
            $book->setImage($fileName);
            $em->persist($book);
            $em->flush();
            return $book;
        }
        return $form;
    }

Pero vemos que tenemos un problema, el cúal nosotros estamos devolviendo el nombre de la imagen solo, lo que tendríamos que hacer es cuando hacemos la peticion de nuestra api, debemos de devolver el valor de la imagen pero la url completa a ese servicio par poder acceder desde fuera x ejm devolvemos name_image.jpeg y queremos que devuelva esto => http://nube.com/name_image.jpeg.
Podemos lograrlo con el componente Serializer de symfony, el cúal nos permite engancharnos al proceso de serialización para realizr las modificaciones que necesitemos paso:
    1) Creamos una carpeta llamada Serializer en nuestra src y dentro un archivo llamado BookNormalizer.php, un BookNormalizer se ennarga de hacer la basicamente de hacer la transformacion de Entidad a json ejm:
    src/Serializer/BookSerializer.php

    <?php

        namespace App\Serializer;

        use App\Entity\Book;
        use Symfony\Component\HttpFoundation\UrlHelper;
        use Symfony\Component\Serializer\Normalizer\ContextAwareNormalizerInterface;
        use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;

        class BookNormalizer implements ContextAwareNormalizerInterface
        {
            private $normalizer;
            private $urlHelper;

            public function __construct(
                ObjectNormalizer $normalizer,
                UrlHelper $urlHelper
            ) {
                $this->normalizer = $normalizer;
                $this->urlHelper = $urlHelper;
            }

            public function normalize($book, string $format = null, array $context = [])
            {
                $data = $this->normalizer->normalize($book, $format, $context);

                if(!empty($book->getImage())) {
                    $data['image'] = $this->urlHelper->getAbsoluteUrl('/storage/default/' . $book->getImage());
                }

                return $data;
            }

            public function supportsNormalization($data, string $format = null, array $context = [])
            {
                return $data instanceof Book;
            }
        }
    Este normalizador nos pide que implementoemos dos funciones, la normalize que es donde nosotros tenemos y podemos modificar los que queremos como en este caso estamos pasando un complemento donde a la imagen le añadimos un path absoluto para poder acceder a la imagen.
    Y la segundo funcion supportsNormalization que lo que tenemos que hacer y lo mas importabnte es pasarle en el retunr el nombre de la entidad que va a soportar esto en este caso Book
    return $data instanceof Book; asi symfony sabra a que entidad hace referencia y los datos que tiene que cambiar.

!!! PHPUnit !!!.- Es una herramineta para poder realixzar test, lo que nos ayuda basicamdnte es ha comprobar que nuestros servicios apesar que por el camino lo vayamos modificando pues este nos devuelva siempre lo mismo que hemos implementado. Nos permite declara test unitarios y test funcionales, nos permite ejecutar por linea de comandos.
Instalación:
    - composer require --dev symfony/phpunit-bridge
    Una vez instalado esto nos pedira que lancemos el sig comando tambien para que nos traiga la libreria phpunit en sí. php bin/phpunit

Para hacer test de Web como el sig ejem debemos de instalar tambien otro paquete por que si no nos da un error ejm:
    composer require --dev symfony/browser-kit symfony/css-selector
    tests/Controller/Api
    <?php

    namespace App\Tests\Controller;

    use Symfony\Bundle\FrameworkBundle\Test\WebTestCase;

    class BookControllerTest extends WebTestCase
    {
        public function testCreateBook()
        {
            $client = static::createClient();

            $client->request('GET', '/api/books');

            $this->assertEquals(400, $client->getResponse()->getStatusCode());
        }
    }

Para nosotro poder hacer test de enpoints, lo recomendable y necesesario para que nos nos falle los test es creasr un db de prueba, symfony nos permite en el package dentro de config generr diff tipos de configuraciones dependiendo el entorno en el que estemos por ejm, aqui estamos creando nosotros un db sqlite donde le estamos pasando los datos que tenemos en nuestro db y para las pruebas de test x ejm:
    - config/packages/test/doctrine.yaml
    doctrine:
    dbal:
        driver: pdo_sqlite
        path: "%kernel.cache_dir%/test.db"
        url: null

    - Luego debemos de lanzar el sig comando:
        bin/console doctrine:database:create --env=test

    - Luego lanzar las migraciones contra esta db de prueba :
        bin/console doctrine:schema:update --env=test --force

!!! Authentication y Security Bundle !!!.- El security nos permite meter seguridad para proteccion, de modo que cuando subamos esta api a un dominio nos nos consuman de todo lado.
Vamos a trabajar con los tokens de cabecera. Debemos de crear nosotros una carpeta Security donde vamos a emepzar a meter los archivos dentro de ahí para el manejor de la seguirdad.

Installation:
    - composer require symfony/security-bundle
    Esto ejecuta algunas recetas.
Al instalar esto cuando nosotros queremos por ejm hacer algun tipo de prueba en los fomrualrios para creación pues no dará un error => "The CSRF token is invalid. Please try to resubmit the form.", esto porque cuando nosotros instalamos este security-bundle este dentro de algunos paquetes que nesitan instalarse se trae el security/csrf que lo que hace es proteger todos los formularios atarvés del token CSRF que basicamente añade como un control de expiración a los forms para que no se puedan submitear después de un cierto tiempo y que los formularios que no tengan ese token por supuesto no sean válidos.
En nustro caso no tenemos una forma de validar este token de una manera sencilla, por lo que vamos a desabilitarlo en nuestros FormType que creamos ses en libro que en Categorias. ejm:
    añadiendo dentro del resolver el crsf_protection => funcionales
    ... rest of code
     $resolver->setDefaults([
            'data_class' => CategoryDto::class,
            'csrf_protection' =>  false
        ]);
    }
Si queremos que ningun formulario de manera global no contenga este tipo de token csrf lo podemos desablitar a nivel de framework x ejm: 
    config/packages/framework.yaml
        framework:
            secret: '%env(APP_SECRET)%'
            csrf_protection: true
    Colocando ese esta opción:  => csrf_protection: true por defecto viene comentada.

Vamos a usar el modelo de GuardAuthentication (docs => https://symfony.com/doc/5.4/security/custom_authenticator.html)

Pero symfony nos pide que tengamos un clase usuario aunque no este perisistida en DB, podemos crear una entity con nustro maker-bundle por ejm:
    - bin/console make:user
    - Este nos crea una "entity User" dentro de La carpeta Security, no nos crea en entity porque hemos decidido no persistir.
    -Nos crea tambien un UserProvider dentro de la misma carpeta que va ha ser el encargado de recuperar la infor del user.
    - Y actualiza el security.yaml, este actualiza y define un provider asociado a la calse que se a creado UserProvider en este caso a App\Security\UserProvider.
    Luego siguiendo la documentacion, una vez tenemos configurado todo esto, debemos de nuestra clase Autenticator debemos de activar en nuestro archivo security.yaml en versinoes actuales esto ya viene automaticamente listo obviamnete como la documentacion dice nuestra clase user debe de extender de  PasswordAuthenticatedUserInterface para que funciones ya que este  PasswordAuthenticatedUserInterface ya viene configurado auto en el security.yaml

Lectura de parametros a servicios.- En este ejm vamos a leer la variable de entorno que le colocamos con nuestro apiToken para la autenticación:
Pasos:
    1)Crear la variable de entorno siempre trabajamos en el env.local ya que esete no se comitea, creamos la varible en el .env como string vacia, luego en el .env.local la llenamos.

    2)En el services.yaml debemos en la sección parameters agregar esta nueva variable con un nombre y que puedo leer la variable de entorno:
        parameters:
            app.api_token: '%env(resolve:APP_API_TOKEN)%'
        El nombre es app.api_token y esta leyendo la variable del APP_API_TOKEN.

    3)En el mismo archivo debemos de indicarle a que servicio debemos de agregar esta variable cuando queremos inyectar ya que symfony puede hacer la inyeccion de dependencias pero si le inyectamos un parametro puro y duro el no lo sabe dentro de services:
        services:
            ... rest of code

            App\Security\ApiKeyAuthenticator:
                arguments:
                    $appApiToken: '%app.api_token%'
    Le pasamos igual un nombre como variable php y el valor, que lo que hace es leer la variable declarada en los parameters, siempre si queremos leer variable de entorno debemos de colocarle entro comiilas y simbolos de porcentaje.

   4)Ya podemos usarlo en nuestro Servicio este caso ApiKeyAuthenticator:
    - Le añadimos al constructor la variable global:
        class ApiKeyAuthenticator extends AbstractAuthenticator
        {
            private $appApiToken;

            public function __construct(string $appApiToken) {
                $this->appApiToken = $appApiToken;
        }

    -Accedemos endonde la vayamos a usar: atarves del this porque esta en nuestro constructor.
        if ($this->appApiToken !== $apiToken) {
            throw new CustomUserMessageAuthenticationException('API Token incorrect');
        }

!!! PHP stan !!!.-
Nota.- podeos actualizar symfony, dentro del composer.json en la seccion "extra", podemos actualizar a cualquier version le colocamos:
     "extra": {
        "symfony": {
            "allow-contrib": false,
            "require": "5.4.*" => here
        }
    },
Luego podemos lanzar el siguiente comando para que actualce las dependencias de forma automatica:
    composer update symfony/* --with-dependecies
    Si por a o b razon da error podemos modificar a mano el composer.json

Instalacióin: Easy Code standar, que es mas un analizador de código que nos va a permitir verificar los standares habituales de programación en php
    - composer require symplify/easy-coding-standard --dev
    Este nos permite trabajar con el php_codeSniffer o PHP-CS-FIXER, esta es la mas habitual usar PHP-CS-FIXER.

    -Segun la documentacion debemos de crear un archivin en la raíz del proyecto llamado ecs.php con el contenido colocado ahí que sirve mucho, en la documentacion esta otro archivo con otro tipo de config básica en este caso la colocamos mas standard que sirve en muchos de los casos, luego para poder ejecutar debemos lanzar los sig comandos:
    Aunque podemos nosotros lanzar vendor/bin/ecs init este me crea un archivo ecs.php ya configuradp un par de cosas y es mejor hacer así entonces una vez instalado lanxamos los sig comandos:
        - vendor/bin/ecs init => me crea un file ecs.php.
        - vendor/bin/ecs check --ansi --no-interaction => esto lee el archivo y lo ejecuta y nos muestra en consola los errores que tenemos.

        - vendor/bin/ecs check --ansi --no-interaction --fix hace lo mismo que el anterior si no que en este caso si puede lo fixea el mismo.
    Pero no es lo mas optimo tarabajar asi, si no hacer uso de los scripts que tambien nos permite symfony en nuestro composer.json añadimos lo sig:
      "scripts": {
        ...rest of code
        "cs": [
            "vendor/bin/ecs check --ansi --no-interaction"
        ],
        "cs-fix": [
            "vendor/bin/ecs check --ansi --no-interaction --fix"
        ],
      }
    Luego en terminal para ejecutarlo lanzamos:
        - composer cs
        - composer cs-fix para usar los scripts debemos de usar composer

Ahora vamos a instalar php stan, esto es más un analizador estético de código que nos permite tener un código mas robusto, nos constorlar mucho el tipdo tmabien.:
Installation: Vamos a usar dos librerias:
    - composer require --dev phpstan/phpstan => libreria completa.
    - composer require --dev phpstan/extension-installer => Esto nos va a permitir es que cada vez que nosotros instalemos una extension para phpstan que tiene varias para Laravel, Symfony, Doctrine pues el la configura por nosotros.

Configuración:
    - Para configurar esto debemos de crear en la raíz del proyecto un archivo con la extension .neon llamado phpstan => phpstan.neon
    phpstan.neon
        parameters:
        level: 1 => es recomendable el nivel 1 para empezar ya que podemos solucionar errores mas grandes y luego irle subiendo el nivel para poder fixear pequeñas cosas
        paths:
            - src => Que patrh queremos que analice.
        excludes_analyse:
            - %rootDir%/src/migrations => que paths queremos que excluya.

Luego debemos de instalar otras extensiones, para poder trabajar con Symfony y Doctrine, porque symfony mete mucha magia con la inyeccion de Deps, Servicios, containers etc y si no estan pues el no va a saber de que tipo son la interfaces que estamos inyectamos o si se encuentran presentes:
    - composer require --dev phpstan/phpstan-symfony
        Lo que hace esto es contarle a phpstan la magia de symfony y asi sepa analizar e interpretar mucho mejor nuestro código.

    -Luego de esto debemos de aadirle otra config a nuestro archivo phpstan.neon, que le indica donde esta el archivo xml que representa el container de nuestra app, por supuesto en entorno de desarrolo no en produccion:
        symfony:
            container_xml_path: 'var/cache/dev/App_KernelDevDebugContainer.xml'

    - Luego instalar para dcotrine: composer require --dev phpstan/phpstan-doctrine, esto lo que hace es que se entere como funciona los métodos mágicos de nuestros Repositories, y que nos los tome como error si no que el sepa que son métodos mágicos que nos da doctrine

    Ahora lo que recomiendan es crear en la raíz del proyecto una acrpeta llamada build/phpstan con un archivo doctrine-orm-booststrap.php con la sig configuracion:
        <?php declare(strict_types = 1);
        use App\Kernel;
        require dirname(__DIR__) . '/../config/bootstrap.php';
        $kernel = new Kernel($_SERVER['APP_ENV'], (bool) $_SERVER['APP_DEBUG']);
        $kernel->boot();
        return $kernel->getContainer()->get('doctrine')->getManager();
    Con esto estamos instanciando el Kernel de Symfony y vamos a coger el Entity Manager de Dcotrine, entonces cuando ejecutemos phpstan el se pasara por aquí que va a devolver la instancia de EntityManager. 
    Luego debemos de añasdir la sig congiguracino al phpstan.neon
        doctrine:
            objectManagerLoader: build/phpstan/doctrine-orm-booststrap.php
    Entonces cuando se ejecute el phpstan va a llamar a este archivo doctrine-orm-booststrap.php va a recuperar eñ EntityManger de aqui y el va automaticamente a detectar los métodos que tiene las etidades a las que estan asociados los Repositorios y un par de cosas más para chequear mas los tipos.

    - Por último debemos de agregar en el phpstan.neon la sig config dentro de doctrine donde agregamos la última el repositoryClass
        doctrine:
            objectManagerLoader: build/phpstan/doctrine-orm-booststrap.php
            repositoryClass: Doctrine/Bundle/DoctrineBundle/Repository/ServiceEntityRepository
    Luego vamos a BookRepository y le añadimos un phpdocs con lo sig, despues de @method:
    /**
     * @method ...etc
     * @extends \Doctrine\Bundle\DoctrineBundle\Repository\ServiceEntityRepository<Book>
     */
    Con esto le decimos a php stan que este repository representa esta clase a la entity y como extiende de ServiceEntityRepositor, Book tiene las sig  propiedades (camops de la entity), y que con estas props puedo hacer uso de los metodos magicos (los que da los Repository) con findByTitle, findByImage etc etc

Para lanzar phpstan vamos a crear un nuevo script:
    "stan": [
        "vendor/bin/phpstan analyse --ansi --no-interaction"
    ]


!!! UUID !!!.- Nos permite generar ids tipo strings no los que nos generan automaticamente doctrine através de mysql numéricos.
Pero primero veamos un comando bastante genial en donde nosotros podemos psar de anotaciones a archivos yaml para poder tener nuestras entidades limpias de anotaciones y manejarlas mediante yaml:
    - bin/console doctrine:mapping:convert yaml ./src
    Lanzando esto vemos que me genera en este caso tengo solo dos entidades me genero archivos llamados 
    App.Entity.Book.orm.yaml y App.Entity.Cayegory.orm.yaml, pero vamos a crear una carpeta llamada doctrine dentro de config.

    -Luego vamos al arichovo doctrine.yaml y tenemos que cmbiar la configuración y en ves de decirle que use annotations le decimos que use yml y le cambiamos la direccion tambien en donde le tenemos los archivos x ejm:
        doctrine.yaml  => Asi viene el archivo por defecto o cuando le configuramos con annotation
        orm:
            ...rest of code
            mappings:
                App:
                    is_bundle: false
                    type: annotation
                    dir: '%kernel.project_dir%/src/Entity' 
                    prefix: 'App\Entity'
                    alias: App

    Como debemos de modificar para que me tome los yml y cambiar la ruta en donde estan las entidades:
    orm:
        ...rest of code
        mappings:
            App:
                is_bundle: false
                type: yml
                dir: '%kernel.project_dir%/config/doctrine' 
                prefix: 'App\Entity'
                alias: App
En algunos casos da error porque nos genera los archivos que dijimos con App.Entity y hace conflicto, porque aveces toma como el namespace repetido para ello podemos cambiar el nombre de los archivos quitando el App.Entity ejm:
    - App.Entity.Book.orm.yml => Book.orm.yml
    - App.Entity.Category.orm.yml => Category.orm.yml
Entonces ya podemos quitar todas las anotaciones en las entidades generadas en el src/Entity.

Ahora vamos a seguir con la instalación de uuid, de ramsey, esta librería basicamente lo que hace es traer el enganche con doctrine de la propia librería ramsey/uuid que lo que hace es generarnos identificadores únicos de 36 carecteres habitualmente

- Instalción:
    - composer require ramsey/uuid-doctrine
    Este ejecuta un receta de flex que lo que hace el es crear un tipo Custom que se va a llamar UuidType

-Configuración:
    - Debemos de empezar a configurar nuestras entidades podemos hacerlo como en entidades con annotations o como entidades como yml que hermos generado en este caso. debemos de añadir la sig configuracion en el yml:
    Book.orm.yml   ---- Category.orm.yml
    id:
         id:
            type: uuid
            generator:
                strategy: CUSTOM  
            customIdGenerator:
                class: Ramsey\Uuid\Doctrine\UuidGenerator
    Por defecto ya viene creado el id: primero solo debemos de colocar el siguiente pedadzo con esto le decimos que el tipo sera un uuid la estrategio Custom y el CustomGenerator encragado.
Luego ya podemos generar una migración, si tenemos el DB vacío no existe ningun problema, pero si tenemos talvés nos de errores por los tipos en la foreign key ya que unos serán uuid (strings) y los normales enteros autoincrementales. Por lo cual existe una forma de modificar esto con la libreria habbim/uuid-to-id pero esta un poco mal publicada por lo cual debemos de cambiar varias cosas para poder instalar esta libreria, pero esta libreria nos viene a solucionar muchos prblemas, comom cambiar el tio de dato, cmabiar las foreign keys y varias cosas mas verificar documentación =>
https://packagist.org/packages/habbim/id-to-uuid.


Pero nosotros debemos de seguir configurando porque como cambiamos esto ya no le dejemamos el trabajo de creación de ids con doctrine si no vamos a autogerar nosotros los uuids ver condiguracion de entidades y el mappinf orm.yml de Book y Category ejm:

    Book.php
  use Ramsey\Uuid\UuidInterface;
- class Book
    {
        private UuidInterface $id;

        private $title;

        private $image;

        private $categories;

        public function __construct(UuidInterface $uuid)
        {
            $this->id = $uuid;
            $this->categories = new ArrayCollection();
        }

        public function getId(): ?UuidInterface
        {
            return $this->id;
        }

    como vemos en la entidad Book en su constructor le obligamos al id que ya venga autocompletdo el campom id como un la instancion de un UuidInterface. lo mismo hacer todas las Entidades hechas.

Otro cambio a nivel de orm.yml:
- App\Entity\Book:
    type: entity
    table: book
    repositoryClass: App\Repository\BookRepository
    id:
        id:
            type: uuid => como vemos aqui le quitamos el resto de configuración que tenía y le dejamos asi tal cual aquí solo con el type: uuid porque no queremos delegar a esta librería => Ramsey\Uuid\Doctrine\UuidGenerator que nos genere si no nosotros a nibel de entidad ya hemos hecho este trabajo

- Otro cambio a nivel de BookManager y CategoryManager que son los encragados de gestionar todo:
    CategoryManager.php
    ...rest of code
    use Ramsey\Uuid\Uuid;
    public function create(): Category
    {
        $category = new Category(Uuid::uuid4());
        return $category;
    }
    Como vemos qui le estammos asigannod un uuid de tipo 4 a los ids tanto en Book como Category y asi seguimos cambiando los métodos que tenemos en los manager ya que estamos devolviendo un string uuid y no un entero.
    ejm:

    use Ramsey\Uuid\UuidInterface;
    public function find(UuidInterface $id): ?Category
    {
        return $this->categoryRepository->find($id);
    }

- Otro cambio a nivel de BookFormProcessor y CategoryFormProcessor.
- Otro cambio a nivel de Controller porque estamos buscando creando por id entero ahora en uuid.
    /**
     * @Rest\Delete(path="/books/{id}")
     * @Rest\View(serializerGroups={"book"}, serializerEnableMaxDepthChecks=true)
     */
    public function deleteAction(
        string $id,
        BookManager $bookManager
    )

!!! VALUE OBJECT !!!.- Estos no son inmutable es decir estos no contendran setters.
Embeddables de doctrine son una caracteristica muy poco conocida y que nos permite trabajar con los value object de una forma más sencilla.
Se crea de la sig manera:
Dentro del archivo Book.orm.yaml a nivel de fields al mismo nivel colocamos lo sig:
    - embedded:
        score:
            class: App\Entity\Book\Score

Luego en el mismo archivo debemos de colocar lo sig alfinal del archivo

App\Entity\Book\Score:
    type: embeddable
    fields:
        value: {type: int}
Pero dentro de nuestro Book.php debemos de nosotros controlar que este embeddable no sea null, porque si el encuentra un null en el campo donde lo va a crear pues me crea un objeto con un null, por eso debemos de controlar que no sea null en ningun momento por lo cual dentro de nuestra entidad libro lo que vamos ah ahcer es en nuestro contructor inicializxarlo vacío:

    public function __construct()
    {
        $this->score = Score::create();
    }
Pero es mejor crear un archivo dentro de donde estamos mapeando los orm de nuestras entidades en vez de tener  => esto App\Entity\Book\Score:
    type: embeddable
    fields:
        value: {type: int}
dentro del mismo archivo porque da error.
Book.Score.orm.yml => aquí creamos con el prefijo Book por la confiuracion de entidades que tenemos en esta  línea => prefix: 'App\Entity' en doctrine.yaml

App\Entity\Book\Score:
    type: embeddable
    fields:
        value: { type: integer }

Luego debemos de crear las migraciones y lanzarlas.

!!! SONATA ADMINN !!! Es muchisimo mas flexible que easy admin.
Debemos de colocar que nos traiga la establidad mínima del paquete:
    - composer require sonata-project/admin-bundle //Fijarse bien en el paquete que sea compatible.

Debemos de instalar esto para que nos funcione todo lo que es de doctrine para poder nosotros generar con la línea de comandos.
composer require sonata-project/doctrine-orm-admin-bundle

Configuracion:
    - Debemos de colocar la sig conf dentro de framework.yaml.
        // config/packages/framework
        translator: {
            fallbacks: ['es']
        }
    - LAs rutas ya vienen configuradas por nosotros gracias a flex, lo que sio debemos es limpiar la cache.

    -Luego lo que si debemos instalar es los assets:
        - bin/console assets:install

Ya con esto debería funcionar, lo que debemos de hacer es colocar las siguiente ruta:
    http://localhost:1000/admin y tendremos nuestro panel de admin.

Sonata admin nos provee de unos comandos para poder nosotros crear nuestras clases de administracion atraves de Dcotrine con el sig comando:
    - bin/console make:sonata:admin
    Luego nos pedira la clase que tengamos y el la va a crear ese panel en eset caso debemos pasarle el namespace completo para tome la clase en este caso Category y la cree en el panel:
      -The fully qualified model class:  => esto nos pide
        -  App\Entity\Category Luegpo nos pedira una serie de confirmsciones que sengun las necesidades la podemos nosotros colocar si o no.
    
!!! EVENT DISPATCHER !!!.- Nos a permitir reaccionar a cosas que sucedan dentro de nuestro sistema mediante eventos.
Symofny tiene una herrmienta llamada profiler que nos permite verificar petiones error logs etc etc.
Instalación:
    - composer require --dev symfony/profiler-pack
Tambine nos provee otra herrameinta llamada varDumper Component que nos va permitir dumpear nuestras variables y mostralas en nuestro profiler:
Instalación:
    - composer require --dev symfony/var-dumper
    - composer require --dev symfony/debug-bundle => esto va de la mano con el de arriba.
    - composer require --dev ekino/phpstan-banned-code => Esto lo instalasmos para nosotros poder agragar un banned code a nuestro php estan para las variable como print_r, dum, var_dump porque nuestro debug_bundle se ha instalado en dev y en produccion no se va a instalar y cuando en produccion quiera acceder a esta variable va a petar, para eso le agregamos al phpstan.neon una config para que no pete y le instalamos eso para que funcione. Esto nos avisa cuando encuentra código que nosotros hemos baneado, invoaciones a echo print_r típicos de debugear con esto php stan nos va a avisar.

Para este DISPATCHER debemos de instalarlo nuestro componente dispatcher de symfony:
    - composer require symfony/event-dispatcher

Nosotros lo que vamos hacer como ejm es cuando creamos un libro, un subscriber va a logear en los logger típocos de Sf.

!!! HTTP CLIENT !!!.- Nos permite hacer llamadas contra apis externas, lo mas recomendado usar con symfony para comunicacion con servicios externos..!!.

Instalación:
  - composer require symfony/http-client
  Funciona mediante inyeccion de dependencias.