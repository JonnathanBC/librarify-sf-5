!!! Rutas y controladores !!!.- Symfony nos recomiendo usar las anotaciones cuando nosotros queremos generar rutas desde un controladore, por lo que nos ofrece un bundle para poder emplear dichas anotacinoes:
Instalacion:
    - composer require annotations
    Lo que hace esto instalar el bundle y ejecuta unas recetas las cuales nos configuran los archivos necesarios para su correcto uso de este paquete, automagicamente symfony lo coloca dentro las configuraciones.

Uso:
    - Podemos usarlo de la sig manera dentro de nuestros Controllers:
<?php

namespace App\Controller;

use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;

class LibraryController extends AbstractController
{
    private $logger;

    public function __construct(LoggerInterface $logger)
    {
        $this->logger = $logger;
    }

    /**
     * @Route("/library/list", name="library_list")
     */
    public function list(Request $request)
    {
        $title = $request->get('title', 'Alegría');
        $this->logger->info('List action called');
        $response = new JsonResponse();
        $response->setData([
            'success' => true,
            'data' => [
                [
                    'id' => 1,
                    'title' => 'Hacia rutas salvajes'
                ],
                [
                    'id' => 2,
                    'title' => 'El nombre del viento'
                ],
                [
                    'id' => 2,
                    'title' => $title
                ]
            ]
        ]);
        return $response;
    }
}

Colocando una anotacion arriba de la clase donde queremos que sea una ruta, es recomendable darle un nombre a nuestra ruta para que sea mas facil acceder a ella mediante el nombre, También podemos ver un poco de Servicios que estamos inyectando directo en la funcion que sería el Request que lo que nos permite es tener toda la infoemacion de la request o peticion que hacemos en este ejem estamos pasanod por query un parametro llamado title donde capturamos en la ruta de nuestro navegador y el libre 3 tendra ese nombre el que le pasemos por query, tambien podemos darle un valor por defcto en el caso que no exita ese valor en la query pues tomará ese valor por defecto en nuestro ejm es fortunata, los controladores de symfony siempre pero siempre deben de retornar una respuesta para ello podemos usar el Objeto Response o JsonResponse como vemos en el ejm de arriba.
Los controladores pueden recibir los Servicios que son basicamente clases que hacen cosas y tpdo estos segicios estna dentro de una cosa que se llama containe, y asi podemos nosotros usar los servicios atraves de la inyeccion de dependencias. con este comando: bin/console debug:container nos dan una lista de los servicios que tenemos en nuestra app.

Como vemos en el ejm de arriba es una forma de inyectar los Servicios mediante su contructor, pero tambien gracias a una configuracion en el archivo config/services.yml podemos acceder a estos servicios s¿directo en la funcion misma donde lo vayamos a usar sin necesidad de utilizr el controlador ejm:

    services.yml => cabe recalcar en las versiones nuevas de symfony esto no viene configurado ya porque ya lo hace por defecto, pero en otras versiones en necesario colocar esto cro que de symfony 5.4 para abajo.

    ...resto of code
    App\Controller\:
        resource: '../src/Controller'
        tags: ['controller.service_arguments']

USO:
    <?php

namespace App\Controller;

use Psr\Log\LoggerInterface;
use Symfony\Bundle\FrameworkBundle\Controller\AbstractController;
use Symfony\Component\HttpFoundation\JsonResponse;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Annotation\Route;

class LibraryController extends AbstractController
{
    /**
     * @Route("/library/list", name="library_list")
     */
    public function list(Request $request, LoggerInterface $logger)
    {
        $title = $request->get('title', 'Alegría');
        $logger->info('List action called inside function');
        $response = new JsonResponse();
        $response->setData([
            'success' => true,
            'data' => [
                [
                    'id' => 1,
                    'title' => 'Hacia rutas salvajes'
                ],
                [
                    'id' => 2,
                    'title' => 'El nombre del viento'
                ],
                [
                    'id' => 2,
                    'title' => $title
                ]
            ]
        ]);
        return $response;
    }
}

Queda más limpio y no es necesario el uso del constructor si no como vemos podemos usar la intyecciion de dependencias directo en la funcion del controlador. Este funcionamiento es a nivel solo de controladores, si usamos en otro lado esto pues deberiamos de usar los constructores como vemos en el primer ejm, revisar documentacion para mas información, cambia segun las versiones de symfony este tipo de cosas.


!!! BASES DE DATOS !!!.- Symofny tiene un gestor de DB por execelencia vamos a llamarlo ORM llamado Doctrine, doctrine tiene como dis funciones :
    1) Nos abstrae la conexión con la BD, es decir, nos trae una capa que nos permite conectarnos a BD sin tenernos que nososotros picar la típicas conslutas de mySQL

    2)Funciona como un ORM lo cual nos permite mapear nuestras clases y objetos php con las tablas que tenmos en MySql y funciona correctamente.

Instalación:
    - composer require symfony/orm-pack
    Esto nos es mas que una receta de flex la cula le decimos que nos traiga todas la librerias, componentes y bundle para trabajar con doctrine, y ademas nos ejecuta una serie de scripts que nos va a configurar una serie de archivos el cual mos servira mucho para trabajar Dcotrine.

    Nos da en el archivo .env una linea de código muy importante que es lo que nos va a permitir conectarnos a la BD. La configuracion de db y cosas importantes como claves siempre las debemos generar dentro del .env.local siempre porque por defecto symfony esto no lo sube al repositorio

También tiene un bundle super práctico llamamdo make bundle el cual nos va a permitir por comandos ejecutar nuestras migraciones, nuestras entidades sin necesidad de hacer manualmente una creando getters y setters si no que automaticamente las crea el con el nombre de cada campo, es una dep de desarrollo:
Instalacion:
    - composer require --dev symfony/maker-bundle
    Entonces nosotros ya una vez teniendo la conexion a nuestra BD podemos lanzar el comando
    bin/console make:entity nameEntity esto nos creara las entidades nos pedira los campos que nosotros queremos colocar dentro de esta entidad y asi se crear automatocamente la entidad con los capos que le pasemos sus getters y setters.

    - Luego cuando estemos listos pues tenemos que crear las migraciones con el sig comando:
        php bin/console make:migration
        Esto creara un archivo dentro de la carpeta migrations donde tendrán las sentencias SQL para crear nuestra entidad y campos que le hayamos especificado.
    -Luego debemos de ejeuctar la migracion con bin/console doctrine:migration:migrate (bin/console d:m:m)

    como persistimos los datos, usando un Servicio de Doctrine llamado EntityManager, o cual nos va a permitir persistir entidades a BD lo debemos de usar como una inteccion de dependencias ejm:


    public function createBook(Request $request, EntityManagerInterface $em)
    {
        $book = new Book();
        $book->setTitle('Hacia rutas salvajes');
        $em->persist($book);
        $em->flush();
    }
}

Tenemos que hacer como vemos dos pasos el persist y el flush, con el persist le decimos, tengo una entidad de php en este caso la clase Book, gestionalo, le decimos que el objeto lo controle el, le decimos a Dcotrine quye tenemos un objeto de la clase libro, ya con el flush lo salvamos en el db.

!!! FOST REST BUNDLE !!!.- Es un bundle como Api PLatform que nos permite montar una api.
Instalación
    -composer require friendsofsymfony/rest-bundle.
    
    -Pero esto nos da un error porque necesita esto un serealizer, que lo que hace es como hiciumos a mano recuperar el librro y convertirlo a json pues este lo hace automaticamente por nosotros. asi que tenemos dos opciones uno de terceros y el propio que symfony saco llamado sereaizer lo vamos a instalar:
        - composer require symfony/serializer-pack
    Una vez instalado el serealizer debemos de agregar ls sig configuracion en el 
    config/packages/framework.yaml:
        ...code

        serializer:
            enabled: true
            mapping:
                paths: ['%Kernel.project_dir%/config/serializer']
    Con el mapping le decimos como queremos mapear las propiedades al formato que nosotros queremos, por ejm al id de un entidad le decimos que le queremos llamar casa por ejm etc. como esa carpeta serializer no existe pues la tenemos que crear dentro de config

    Dentro de esta carpeta creamos el archivo yaml de la entidad que estamos queriendo mapear ejm:
    config/serializer/Entity/Book.yaml

        App\Entity\Book:
    attributes:
        id: 
            groups: ['book']
        title:
            groups: ['book']
    Basicamente lo que hace los serializer es definir grupos de serealizacion de modo que en función de cual especiquemos podemos definir que propiedades del objeto aparecen o no.

Ahora temos que definir el Fost Rest Bundle:
    en el archivo routes.yaml agregamos lo sig:
        api:
            resource: ../../src/Controller/Api
            type: annotation
            prefix: /api
    Con esto estamos habilitando las rutas con el prefijo api.

Luego debemo de configurar el archivo fos_rest.yml (dentro esta la conf ya pegada).
Luego debemos de instalar un Validator pata que funione nuestro fostRest, el componente Validaotr nos permite validar entidades mas bien objetos en función de unas reglas que nosotros definamos. por ejm queremos hacer una llamada en post pues podemos validar los datos que estamos enviando:

Instalacion:
    - composer require symfony/validator twig doctrine/annotations
    El Validator depende de las annotations de doctrine por eso lo estamos instalado qui tambien y este doctrine depnde de Twig entonces por eso estamos instalando los 3.

Una vez tenemos todo esto podemos nosotros crear los controladores dentro de nuestra carpeta api que especificamos en la configuracion de la ruta oara qiue este tenga el prefijo /api a todas nuestras rutas ejm:

    <?php

namespace App\Controller\Api;

use App\Repository\BookRepository;
use FOS\RestBundle\Controller\AbstractFOSRestController;
use FOS\RestBundle\Controller\Annotations as Rest;
use Symfony\Component\HttpFoundation\Request;

class BooksController extends AbstractFOSRestController
{
    /**
     * @Rest\Get(path="/books")
     * @Rest\View(serializerGroups={"book"}, serializerEnableMaxDepthChecks=true)
     */
    public function getActions(Request $request, BookRepository $bookRepository)
    {
        return $bookRepository->findAll();
    }
}
 Las anotaciones deben ser de FostRestBundle

!!! FORMULARIOS !!!.- Para esto debemos de instalar el componente formulario de symfony:
    - composer require symfony/form
    Este nos permite declarar formularios y que procesaremos en nuestros controladores, dentro de src ccreamois un carpeta llamada Form y por convencion una carpeta llamada Type¿ y dentro creamos los files necesarios para esto de los Forms.
    src/Form/Type/BookFormType.php

    <?php

    namespace App\Form\Type;

    use App\Entity\Book;
    use Symfony\Component\Form\AbstractType;
    use Symfony\Component\Form\Extension\Core\Type\TextType;
    use Symfony\Component\Form\FormBuilderInterface;
    use Symfony\Component\OptionsResolver\OptionsResolver;

    class BookFormType extends AbstractType
    {
        public function buildForm(FormBuilderInterface $builder, array $options): void
        {
            $builder->add('title', TextType::class);
        }

        public function configureOptions(OptionsResolver $resolver)
        {
            $resolver->setDefaults([
                'data_class' => Book::class
            ]);
        }
        
    }
Aqui lo que estamos haciendo en la primera funcione es inyectrar FormBuilderInterface $builder lo que nos da este servicio es una serie de metodo los cuales podemos nosotros usarlos en este caso estamos usando add que lo que hace es aladir un campo title y como segundo parametro recibe el tipo de campo en este caso TextType, luego en la 2da funcion  es inyectarnos el OptionsResolver, esto nos sirve para nosotros especidficarle a que entidad esta haciendo referencia.

Luego vamos a usarlo dentro de nuestro controller:


Aunque aveces falla esto por lo cual debemos de pasarle en el body un nombre porque symfony guarada los formularios que creamos con un nombre ejm:

Esto le pasamos en el body de la peticion:;
    "book_form":
        {
            "title": "El pozo de la ascención"
        }
Si queremos evitar esto, para no tener que estar colocnado cada rato el nombre del form, dentro de nuestro BookTypeForm en este caso vamos a añadir dos metodos ejm:

    ...rest of code
    //cuando trabajamos con Twig
    public function getBlockPrefix()
    {
        return '';
    }

    public function getName()
    {
        return '';
    }
De modo que asi ya no debemos especificar el nombre del form en la request.
Ahora vamos a colocar constrains a diff campos de nuestra app podemos usar yaml o annotations.

Con Annotations:
use Symfony\Component\Validator\Constraints as Assert;

    /**
     * @Assert\NotBlank
     */
    protected $firstName;

    Esto dentro del controller y arriba del campos que queremos que nos sea blanco o tenga alguna constraints:

Mediante yaml: tenemos que crear una carpeta dentro de config llamado validator y dentro un file que hacemos por convencion tenga el mismo nombre de la entidad que vamos a agregar este tipo de constraint

config/validator/Book.yaml

    